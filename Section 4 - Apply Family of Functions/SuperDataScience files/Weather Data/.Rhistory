ChrisBosh_FG <- c(549,543,507,615,600,524,393,485,492,343)
ChrisPaul_FG <- c(407,381,630,631,314,430,425,412,406,568)
KevinDurant_FG <- c(306,306,587,661,794,711,643,731,849,238)
DerrickRose_FG <- c(208,208,208,574,672,711,302,0,58,338)
DwayneWade_FG <- c(699,472,439,854,719,692,416,569,415,509)
#Matrix
FieldGoals <- rbind(KobeBryant_FG, JoeJohnson_FG, LeBronJames_FG, CarmeloAnthony_FG, DwightHoward_FG, ChrisBosh_FG, ChrisPaul_FG, KevinDurant_FG, DerrickRose_FG, DwayneWade_FG)
rm(KobeBryant_FG, JoeJohnson_FG, LeBronJames_FG, CarmeloAnthony_FG, DwightHoward_FG, ChrisBosh_FG, ChrisPaul_FG, KevinDurant_FG, DerrickRose_FG, DwayneWade_FG)
colnames(FieldGoals) <- Seasons
rownames(FieldGoals) <- Players
#Field Goal Attempts
KobeBryant_FGA <- c(2173,1757,1690,1712,1569,1639,1336,1595,73,713)
JoeJohnson_FGA <- c(1395,1139,1497,1420,1386,1161,931,1052,1018,1025)
LeBronJames_FGA <- c(1823,1621,1642,1613,1528,1485,1169,1354,1353,1279)
CarmeloAnthony_FGA <- c(1572,1453,1481,1207,1502,1503,1025,1489,1643,806)
DwightHoward_FGA <- c(881,873,974,979,834,1044,726,813,800,423)
ChrisBosh_FGA <- c(1087,1094,1027,1263,1158,1056,807,907,953,745)
ChrisPaul_FGA <- c(947,871,1291,1255,637,928,890,856,870,1170)
KevinDurant_FGA <- c(647,647,1366,1390,1668,1538,1297,1433,1688,467)
DerrickRose_FGA <- c(436,436,436,1208,1373,1597,695,0,164,835)
DwayneWade_FGA <- c(1413,962,937,1739,1511,1384,837,1093,761,1084)
#Matrix
FieldGoalAttempts <- rbind(KobeBryant_FGA, JoeJohnson_FGA, LeBronJames_FGA, CarmeloAnthony_FGA, DwightHoward_FGA, ChrisBosh_FGA, ChrisPaul_FGA, KevinDurant_FGA, DerrickRose_FGA, DwayneWade_FGA)
rm(KobeBryant_FGA, JoeJohnson_FGA, LeBronJames_FGA, CarmeloAnthony_FGA, DwightHoward_FGA, ChrisBosh_FGA, ChrisPaul_FGA, KevinDurant_FGA, DerrickRose_FGA, DwayneWade_FGA)
colnames(FieldGoalAttempts) <- Seasons
rownames(FieldGoalAttempts) <- Players
#Points
KobeBryant_PTS <- c(2832,2430,2323,2201,1970,2078,1616,2133,83,782)
JoeJohnson_PTS <- c(1653,1426,1779,1688,1619,1312,1129,1170,1245,1154)
LeBronJames_PTS <- c(2478,2132,2250,2304,2258,2111,1683,2036,2089,1743)
CarmeloAnthony_PTS <- c(2122,1881,1978,1504,1943,1970,1245,1920,2112,966)
DwightHoward_PTS <- c(1292,1443,1695,1624,1503,1784,1113,1296,1297,646)
ChrisBosh_PTS <- c(1572,1561,1496,1746,1678,1438,1025,1232,1281,928)
ChrisPaul_PTS <- c(1258,1104,1684,1781,841,1268,1189,1186,1185,1564)
KevinDurant_PTS <- c(903,903,1624,1871,2472,2161,1850,2280,2593,686)
DerrickRose_PTS <- c(597,597,597,1361,1619,2026,852,0,159,904)
DwayneWade_PTS <- c(2040,1397,1254,2386,2045,1941,1082,1463,1028,1331)
#Matrix
Points <- rbind(KobeBryant_PTS, JoeJohnson_PTS, LeBronJames_PTS, CarmeloAnthony_PTS, DwightHoward_PTS, ChrisBosh_PTS, ChrisPaul_PTS, KevinDurant_PTS, DerrickRose_PTS, DwayneWade_PTS)
rm(KobeBryant_PTS, JoeJohnson_PTS, LeBronJames_PTS, CarmeloAnthony_PTS, DwightHoward_PTS, ChrisBosh_PTS, ChrisPaul_PTS, KevinDurant_PTS, DerrickRose_PTS, DwayneWade_PTS)
colnames(Points) <- Seasons
rownames(Points) <- Players
Homework: Basketball Free Throws - S4, L43
#You have been supplied data for two more additional in-game statistics:
## Free Throws
## Free Throw Attempts
#You need to create three plots that portray the following insights:
## Free Throw Attemps per game
## Accuracy of Free Throws
## Player playing style (2 vs 3 points preference) excluding Free Throws*
### Playing style = ratio of Points to FieldGoals, but you have to exclude Free Throws here
#*Each Free Throw is worth 1 point
#The data has been supplied in the form of vectors. You will have to create the two matrics before you proceed with the analysis.
#----Data----
#Seasons
Seasons <- c("2005","2006","2007","2008","2009","2010","2011","2012","2013","2014")
#Players
Players <- c("KobeBryant","JoeJohnson","LeBronJames","CarmeloAnthony","DwightHoward","ChrisBosh","ChrisPaul","KevinDurant","DerrickRose","DwayneWade")
#Free Throws
KobeBryant_FT <- c(696,667,623,483,439,483,381,525,18,196)
JoeJohnson_FT <- c(261,235,316,299,220,195,158,132,159,141)
LeBronJames_FT <- c(601,489,549,594,593,503,387,403,439,375)
CarmeloAnthony_FT <- c(573,459,464,371,508,507,295,425,459,189)
DwightHoward_FT <- c(356,390,529,504,483,546,281,355,349,143)
ChrisBosh_FT <- c(474,463,472,504,470,384,229,241,223,179)
ChrisPaul_FT <- c(394,292,332,455,161,337,260,286,295,289)
KevinDurant_FT <- c(209,209,391,452,756,594,431,679,703,146)
DerrickRose_FT <- c(146,146,146,197,259,476,194,0,27,152)
DwayneWade_FT <- c(629,432,354,590,534,494,235,308,189,284)
#Matrix
#Free Throws matrix
# <put your code here>
FreeThrows <- rbind(KobeBryant_FT, JoeJohnson_FT,
LeBronJames_FT, CarmeloAnthony_FT,
DwightHoward_FT, ChrisBosh_FT,
ChrisPaul_FT, KevinDurant_FT,
DerrickRose_FT, DwayneWade_FT)
#remove the vectors to clear up the workspace; too many things in the workspace can slow down your computer!
rm(KobeBryant_FT, JoeJohnson_FT,
LeBronJames_FT, CarmeloAnthony_FT,
DwightHoward_FT, ChrisBosh_FT,
ChrisPaul_FT, KevinDurant_FT,
DerrickRose_FT, DwayneWade_FT)
colnames(FreeThrows) <- Seasons
rownames(FreeThrows) <- Players
#Free Throw Attempts
KobeBryant_FTA <- c(819,768,742,564,541,583,451,626,21,241)
JoeJohnson_FTA <- c(330,314,379,362,269,243,186,161,195,176)
LeBronJames_FTA <- c(814,701,771,762,773,663,502,535,585,528)
CarmeloAnthony_FTA <- c(709,568,590,468,612,605,367,512,541,237)
DwightHoward_FTA <- c(598,666,897,849,816,916,572,721,638,271)
ChrisBosh_FTA <- c(581,590,559,617,590,471,279,302,272,232)
ChrisPaul_FTA <- c(465,357,390,524,190,384,302,323,345,321)
KevinDurant_FTA <- c(256,256,448,524,840,675,501,750,805,171)
DerrickRose_FTA <- c(205,205,205,250,338,555,239,0,32,187)
DwayneWade_FTA <- c(803,535,467,771,702,652,297,425,258,370)
#Matrix
#Free Throw Attempts matrix
# <put your code here>
FreeThrowAttempts <- rbind(KobeBryant_FTA, JoeJohnson_FTA,
LeBronJames_FTA, CarmeloAnthony_FTA,
DwightHoward_FTA, ChrisBosh_FTA,
ChrisPaul_FTA, KevinDurant_FTA,
DerrickRose_FTA, DwayneWade_FTA)
rm(KobeBryant_FTA, JoeJohnson_FTA,
LeBronJames_FTA, CarmeloAnthony_FTA,
DwightHoward_FTA, ChrisBosh_FTA,
ChrisPaul_FTA, KevinDurant_FTA,
DerrickRose_FTA, DwayneWade_FTA)
colnames(FreeThrowAttempts) <- Seasons
rownames(FreeThrowAttempts) <- Players
FreeThrowAttempts
myplot <- function(data, rows=1:10){
Data <- data[rows,, drop=F]     #data becomes the data file
Data
matplot(t(Data), type="b", pch=15:18, col=c(1:4,6))
legend("bottomleft", inset=0.005, legend=Players[rows],
col=c(1:4,6), pch=15:18, horiz=F,
text.width=0.65, ncol=2, cex=0.65)
}
myplot(FreeThrowAttempts)
## Free Throw Attemps per game
myplot(FreeThrowAttempts / Games)
View(myplot)
View(myplot)
myplot <- function(z, who=1:10) {
matplot(t(z[who,,drop=F]), type="b", pch=15:18, col=c(1:4,6), main="Basketball Players Analysis")
legend("bottomleft", inset=0.01, legend=Players[who], col=c(1:4,6), pch=15:18, horiz=F)
}
myplot(FreeThrowAttempts)
(Points - FreeThrows) / FieldGoals
#3.Player playing style (2 vs 3 points preference) excluding Free Throws*
### Playing style = ratio of Points to FieldGoals, but you have to exclude Free Throws here
#*Each Free Throw is worth 1 point
PlayingStyle <- (Points - FreeThrows) / FieldGoals
myplot(PlayingStyle)
R.version.string
installr: install.packages("installr") and library(installr)
install.packages("installr") and library(installr)
install.packages("installr")
library(installr)
updateR()
#---------------- Nesting apply() Functions- S4, L49
Weather
lapply(Weather, rowMeans)
#---------------- Section 4: "Apply" Family of Functions
setwd("~/R Programming - Advanced Analytics in R for Data Science/Section 4 - Apply Family of Functions/SuperDataScience files")
getwd()
save.image("~/R Programming - Advanced Analytics in R for Data Science/Section 4 - Apply Family of Functions/workspaceSection4.RData")
#apply family of functions are like shortcuts for loops in R
#---------------- Project Brief: Weather Patterns - S4, L40
#You are working on a project for a meteorology bureau. You have been supplied weather data for 4 cities in the US: Chicago, NewYork, Houston and SanFrancisco.
#You are required to deliver the following outputs:
#1. A table showing the annual averages of each observed metric for every city
#2. A table showing by how much temperature fluctuates each month from min to max (in %). Take min temperature as the base
#3. A table showing the annual maximums of each observed metric for every city
#4. A table showing the annual minimums of each observed metric for every city
#5. A table showing in which months the annual maximums of each metric were observed in every city (Advanced)
#---------------- Import Data into R - S4, L41
getwd()
setwd("~/R Programming - Advanced Analytics in R for Data Science/Section 4 - Apply Family of Functions/SuperDataScience files/Weather Data")
getwd()
#setwd(".\\Weather Data")    the dot refers to the working directory you're already using
Chicago <- read.csv("Chicago-F.csv", row.names=1)    #row.names=1 takes the row names from the first col
NewYork <- read.csv("NewYork-F.csv", row.names=1)
Houston <- read.csv("Houston-F.csv", row.names=1)
SanFrancisco <- read.csv("SanFrancisco-F.csv", row.names=1)
#when you use the function read.csv(), data are imported as a data frame
#check to make sure it was imported as a DF:
is.data.frame(Chicago)
is.data.frame(NewYork)
is.data.frame(Houston)
is.data.frame(SanFrancisco)
#convert to matrices (because you don't need them to be DFs since all the data are numeric):
Chicago <- as.matrix(Chicago)
NewYork <- as.matrix(NewYork)
Houston <- as.matrix(Houston)
SanFrancisco <- as.matrix(SanFrancisco)
#check:
is.matrix(Chicago)
is.matrix(NewYork)
is.matrix(Houston)
is.matrix(SanFrancisco)
#put all of them into a list:
Weather <- list(Chicago=Chicago, NewYork=NewYork, Houston=Houston, SanFrancisco=SanFrancisco)
Weather
Weather[3]       #returns data as a list
Weather[[3]]     #returns just the component
Weather$Houston  #returns just the component
#---------------- What is the Apply Family? - S4, L42
#apply(MATRIXNAME, 1 or 2, function)     1=rows, 2=columns         function=mean, max, min, etc
#The Apply Family:
#apply - use on a matrix; either the rows or columns
#tapply - use on a vector to extract subgroups and apply a function to them
#by - use on data frames; same concepts as in group by in SQL
#eapply - use on an environment (E)
#lapply - apply a function to elements of a list (L)
#sapply - a version of lapply; can simplify (S) the result so it's not presented as a list
#vapply - has a pre-specified type of return value (V)
#replicate - run a function several times; usually used with generation of random variables; not the same as rep()
#mapply - multivariate (M) version of sapply; arguments can be recycled
#rapply - recursive (R) version of lapply
#---------------- Using apply() - S4, L43
?apply
apply(Chicago, 1, mean)
#check:
mean(Chicago["DaysWithPrecip",])
#analyze one city:
Chicago
apply(Chicago, 1, max)
apply(Chicago, 1, min)
#for practice:
apply(Chicago, 2, max)   #doesn't make much sense, but good exercise
apply(Chicago, 2, min)
#compare:
apply(Chicago, 1, mean)
apply(NewYork, 1, mean)
apply(Houston, 1, mean)
apply(SanFrancisco, 1, mean)
#<<< (nearly) deliverable 1: but there is a faster way
#---------------- Recreating the apply() Function with Loops (Advanced Topic) - S4, L44
Chicago
#find the mean of every row:
#1. via loops
output <- NULL    #preparing an empty vector for our results
for(i in 1:5){    #run cycle
output[i] <- mean(Chicago[i,])
}
output
names(output) <- rownames(Chicago)
output
#2. via apply function
apply(Chicago, 1, mean)
#---------------- Using lapply() - S4, L45
?lapply
#lapply - apply a function to a list or vector
Chicago
#transpose Chicago
t(Chicago)
Weather
#example 1: transpose all components of the Weather list
mynewlist <- lapply(Weather, t)    # same as    list(t(Weather$Chicago), t(Weather$NewYork), t(Weather$Houston), t(Weather$SanFrancisco))
mynewlist
#example 2:
Chicago
rbind(Chicago, NewRow=1:12)
lapply(Weather, rbind, NewRow=1:12)
#example 3:
?rowMeans    #form row and col sums and means
rowMeans(Chicago)   #identical to apply(Chicago, 1, mean)
lapply(Weather, rowMeans)
#<<< (nearly) deliverable 1: even better, but will improve further
#rowMeans
#colMeans
#rowSums
#colSums
lapply(Weather, colMeans)
#---------------- Combining lapply() with []- S4, L46
Weather
Weather$Chicago[1,1]
#or
Weather[[1]][1,1]
lapply(Weather, "[", 1, 1)    #"[" refers to the subset single bracket, so .."[", 1, 1... will give you the first row, first column
Weather
lapply(Weather, "[", 1,)
lapply(Weather, "[", , 3)
#or
lapply(Weather, "[", , "Mar")
#---------------- Adding Your Own Functions - S4, L47
lapply(Weather, rowMeans)
lapply(Weather, function(x) x[1,])   #1st row of every matrix
lapply(Weather, function(x) x[5,])   #5th row of every matrix
lapply(Weather, function(x) x[,12])  #December col for each matrix
lapply(Weather, function(z) z[1,] - z[2,])  #difference between 1st and 2nd rows AKA difference between the AvgHigh_F and AvgLow_F
lapply(Weather, function(z) round((z[1,]-z[2,])/z[2,], 2))   #.... , 2) is asking for 2 decimal places
#<<< deliverable 2: temp fluctuations, will improve
#practice: divide AvgPrecip_inch by DaysWithPrecip
lapply(Weather, function(y) round(y[3,]/y[4,], 2))
#---------------- Using sapply() - S4, L48
?sapply
#sapply - simpler version of lapply
Weather
#AvgHigh_F for July
lapply(Weather, "[", 1,"Jul")
#or
lapply(Weather, "[",1, 7)
#returns a vector (in this case) instead of a list (like lapply)
sapply(Weather, "[", 1,"Jul")
#or
sapply(Weather, "[",1, 7)
#AvgHigh_F for 4th quarter:
lapply(Weather, "[", 1, 10:12)
sapply(Weather, "[", 1, 12:12)   #more visually pleasing!! matrix instead of a list
#another example:
lapply(Weather, rowMeans)
sapply(Weather, rowMeans)
round(sapply(Weather, rowMeans), 2)    #<<< deliverable 1: awesome!
#another example:
lapply(Weather, function(z) round((z[1,]-z[2,])/z[2,], 2))
sapply(Weather, function(z) round((z[1,]-z[2,])/z[2,], 2))  #<<< deliverable 2!
#by the way:
sapply(Weather, rowMeans, simplify=FALSE)  #same as lapply
#---------------- Nesting apply() Functions- S4, L49
Weather
lapply(Weather, rowMeans)
#---------------- Section 4: "Apply" Family of Functions
setwd("~/R Programming - Advanced Analytics in R for Data Science/Section 4 - Apply Family of Functions/SuperDataScience files")
getwd()
save.image("~/R Programming - Advanced Analytics in R for Data Science/Section 4 - Apply Family of Functions/workspaceSection4.RData")
#apply family of functions are like shortcuts for loops in R
#---------------- Project Brief: Weather Patterns - S4, L40
#You are working on a project for a meteorology bureau. You have been supplied weather data for 4 cities in the US: Chicago, NewYork, Houston and SanFrancisco.
#You are required to deliver the following outputs:
#1. A table showing the annual averages of each observed metric for every city
#2. A table showing by how much temperature fluctuates each month from min to max (in %). Take min temperature as the base
#3. A table showing the annual maximums of each observed metric for every city
#4. A table showing the annual minimums of each observed metric for every city
#5. A table showing in which months the annual maximums of each metric were observed in every city (Advanced)
#---------------- Import Data into R - S4, L41
getwd()
setwd("~/R Programming - Advanced Analytics in R for Data Science/Section 4 - Apply Family of Functions/SuperDataScience files/Weather Data")
getwd()
#setwd(".\\Weather Data")    the dot refers to the working directory you're already using
Chicago <- read.csv("Chicago-F.csv", row.names=1)    #row.names=1 takes the row names from the first col
NewYork <- read.csv("NewYork-F.csv", row.names=1)
Houston <- read.csv("Houston-F.csv", row.names=1)
SanFrancisco <- read.csv("SanFrancisco-F.csv", row.names=1)
#when you use the function read.csv(), data are imported as a data frame
#check to make sure it was imported as a DF:
is.data.frame(Chicago)
is.data.frame(NewYork)
is.data.frame(Houston)
is.data.frame(SanFrancisco)
#convert to matrices (because you don't need them to be DFs since all the data are numeric):
Chicago <- as.matrix(Chicago)
NewYork <- as.matrix(NewYork)
Houston <- as.matrix(Houston)
SanFrancisco <- as.matrix(SanFrancisco)
#check:
is.matrix(Chicago)
is.matrix(NewYork)
is.matrix(Houston)
is.matrix(SanFrancisco)
#put all of them into a list:
Weather <- list(Chicago=Chicago, NewYork=NewYork, Houston=Houston, SanFrancisco=SanFrancisco)
Weather
Weather[3]       #returns data as a list
Weather[[3]]     #returns just the component
Weather$Houston  #returns just the component
#---------------- What is the Apply Family? - S4, L42
#apply(MATRIXNAME, 1 or 2, function)     1=rows, 2=columns         function=mean, max, min, etc
#The Apply Family:
#apply - use on a matrix; either the rows or columns
#tapply - use on a vector to extract subgroups and apply a function to them
#by - use on data frames; same concepts as in group by in SQL
#eapply - use on an environment (E)
#lapply - apply a function to elements of a list (L)
#sapply - a version of lapply; can simplify (S) the result so it's not presented as a list
#vapply - has a pre-specified type of return value (V)
#replicate - run a function several times; usually used with generation of random variables; not the same as rep()
#mapply - multivariate (M) version of sapply; arguments can be recycled
#rapply - recursive (R) version of lapply
#---------------- Using apply() - S4, L43
?apply
apply(Chicago, 1, mean)
#check:
mean(Chicago["DaysWithPrecip",])
#analyze one city:
Chicago
apply(Chicago, 1, max)
apply(Chicago, 1, min)
#for practice:
apply(Chicago, 2, max)   #doesn't make much sense, but good exercise
apply(Chicago, 2, min)
#compare:
apply(Chicago, 1, mean)
apply(NewYork, 1, mean)
apply(Houston, 1, mean)
apply(SanFrancisco, 1, mean)
#<<< (nearly) deliverable 1: but there is a faster way
#---------------- Recreating the apply() Function with Loops (Advanced Topic) - S4, L44
Chicago
#find the mean of every row:
#1. via loops
output <- NULL    #preparing an empty vector for our results
for(i in 1:5){    #run cycle
output[i] <- mean(Chicago[i,])
}
output
names(output) <- rownames(Chicago)
output
#2. via apply function
apply(Chicago, 1, mean)
#---------------- Using lapply() - S4, L45
?lapply
#lapply - apply a function to a list or vector
Chicago
#transpose Chicago
t(Chicago)
Weather
#example 1: transpose all components of the Weather list
mynewlist <- lapply(Weather, t)    # same as    list(t(Weather$Chicago), t(Weather$NewYork), t(Weather$Houston), t(Weather$SanFrancisco))
mynewlist
#example 2:
Chicago
rbind(Chicago, NewRow=1:12)
lapply(Weather, rbind, NewRow=1:12)
#example 3:
?rowMeans    #form row and col sums and means
rowMeans(Chicago)   #identical to apply(Chicago, 1, mean)
lapply(Weather, rowMeans)
#<<< (nearly) deliverable 1: even better, but will improve further
#rowMeans
#colMeans
#rowSums
#colSums
lapply(Weather, colMeans)
#---------------- Combining lapply() with []- S4, L46
Weather
Weather$Chicago[1,1]
#or
Weather[[1]][1,1]
lapply(Weather, "[", 1, 1)    #"[" refers to the subset single bracket, so .."[", 1, 1... will give you the first row, first column
Weather
lapply(Weather, "[", 1,)
lapply(Weather, "[", , 3)
#or
lapply(Weather, "[", , "Mar")
#---------------- Adding Your Own Functions - S4, L47
lapply(Weather, rowMeans)
lapply(Weather, function(x) x[1,])   #1st row of every matrix
lapply(Weather, function(x) x[5,])   #5th row of every matrix
lapply(Weather, function(x) x[,12])  #December col for each matrix
lapply(Weather, function(z) z[1,] - z[2,])  #difference between 1st and 2nd rows AKA difference between the AvgHigh_F and AvgLow_F
lapply(Weather, function(z) round((z[1,]-z[2,])/z[2,], 2))   #.... , 2) is asking for 2 decimal places
#<<< deliverable 2: temp fluctuations, will improve
#practice: divide AvgPrecip_inch by DaysWithPrecip
lapply(Weather, function(y) round(y[3,]/y[4,], 2))
#---------------- Using sapply() - S4, L48
?sapply
#sapply - simpler version of lapply
Weather
#AvgHigh_F for July
lapply(Weather, "[", 1,"Jul")
#or
lapply(Weather, "[",1, 7)
#returns a vector (in this case) instead of a list (like lapply)
sapply(Weather, "[", 1,"Jul")
#or
sapply(Weather, "[",1, 7)
#AvgHigh_F for 4th quarter:
lapply(Weather, "[", 1, 10:12)
sapply(Weather, "[", 1, 12:12)   #more visually pleasing!! matrix instead of a list
#another example:
lapply(Weather, rowMeans)
sapply(Weather, rowMeans)
round(sapply(Weather, rowMeans), 2)    #<<< deliverable 1: awesome!
#another example:
lapply(Weather, function(z) round((z[1,]-z[2,])/z[2,], 2))
sapply(Weather, function(z) round((z[1,]-z[2,])/z[2,], 2))  #<<< deliverable 2!
#by the way:
sapply(Weather, rowMeans, simplify=FALSE)  #same as lapply
#---------------- Nesting apply() Functions- S4, L49
Weather
lapply(Weather, rowMeans)
lapply(Weather, rowMeans)
apply(Chicago, 1, max)
#apply across whole list:
lapply(Weather, apply, 1, max)
sapply(Weather, apply, 1, max)
#or:
lapply(Weather, function(x) apply(x, 1, max))
sapply(Weather, function(x) apply(x, 1, max))
Chicago[1,]
which.max(Chicago[1,])
names(which.max(Chicago[1,]))
Weather
apply(Chicago, 1, function(x) names(which.max(x)))   #x = (Chicago[1,])
#iterate the above apply function over the entire list
lapply(Weather, function(y) apply(y, 1, function(x) names(which.max(x))))   #see 9:15 of lecture 50 if confused!
sapply(Weather, function(y) apply(y, 1, function(x) names(which.max(x))))
lapply(Weather, "[", 1, 1)    #"[" refers to the subset single bracket, so .."[", 1, 1... will give you the first row, first column
lapply(Weather, "[", 1,)
lapply(Weather, "[", , 3)     #third column of each component
Weather
#or
lapply(Weather, "[", , "Mar")
sapply(Weather, "[", , "Mar")
lapply(Weather, function(z) z[1,] - z[2,])  #difference between 1st and 2nd rows AKA difference between the AvgHigh_F and AvgLow_F
#<<< deliverable 2: temp fluctuations, will improve
sapply(Weather, function(z) z[1,] - z[2,])
#practice: divide AvgPrecip_inch by DaysWithPrecip
lapply(Weather, function(y) round(y[3,]/y[4,], 2))
lapply(Weather, function(y) round(y["AvgPrecip_inch",]/y["DayesWithPrecip",], 2))
sapply(Weather, function(y) round(y[3,]/y[4,], 2))
#returns a vector (in this case) instead of a list (like lapply)
sapply(Weather, "[", 1,"Jul")
#AvgHigh_F for 4th quarter:
lapply(Weather, "[", 1, 10:12)
sapply(Weather, "[", 1, 12:12)   #more visually pleasing!! matrix instead of a list
sapply(Weather, "[", 1, 10:12)   #more visually pleasing!! matrix instead of a list
#---------------- which.max() and which.min() (Advanced Topic) - S4, L50
#which.max()
?which.max
#iterate the above apply function over the entire list:
lapply(Weather, function(y) apply(y, 1, function(x) names(which.max(x))))   #see 9:15 of lecture 50 if confused!
sapply(Weather, function(y) apply(y, 1, function(x) names(which.max(x))))
M1 <- rbind(c(100,200,300,400,500), rep(10,5))
View(M1)
M2 <- rbind(1:5, rep(10,5))
M1
M2
